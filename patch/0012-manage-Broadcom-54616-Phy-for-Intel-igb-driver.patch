From 3e3667f4da394619ea6a18f499eb0266d3b48b63 Mon Sep 17 00:00:00 2001
From: Sergey Popovich <sergey.popovich@ordnance.co>
Date: Thu, 9 Aug 2018 14:45:27 +0300
Subject: Manage Broadcom 54616 Phy for Intel igb driver

Signed-off-by: Sergey Popovich <sergey.popovich@ordnance.co>
---
 drivers/net/ethernet/intel/igb/Makefile        |   2 +-
 drivers/net/ethernet/intel/igb/bcm_phy.c       | 208 +++++++++++++++++++++++++
 drivers/net/ethernet/intel/igb/e1000_82575.c   |   5 +
 drivers/net/ethernet/intel/igb/e1000_82575.h   |   2 +
 drivers/net/ethernet/intel/igb/e1000_defines.h |   7 +
 drivers/net/ethernet/intel/igb/e1000_phy.c     | 121 ++++++++++++++
 drivers/net/ethernet/intel/igb/e1000_phy.h     |   3 +
 drivers/net/ethernet/intel/igb/igb_main.c      |   8 +
 8 files changed, 355 insertions(+), 1 deletion(-)
 create mode 100644 drivers/net/ethernet/intel/igb/bcm_phy.c

diff --git a/drivers/net/ethernet/intel/igb/Makefile b/drivers/net/ethernet/intel/igb/Makefile
index 5bcb2de..1142a06 100644
--- a/drivers/net/ethernet/intel/igb/Makefile
+++ b/drivers/net/ethernet/intel/igb/Makefile
@@ -32,5 +32,5 @@
 obj-$(CONFIG_IGB) += igb.o
 
 igb-objs := igb_main.o igb_ethtool.o e1000_82575.o \
-	    e1000_mac.o e1000_nvm.o e1000_phy.o e1000_mbx.o \
+	    e1000_mac.o e1000_nvm.o e1000_phy.o e1000_mbx.o bcm_phy.o \
 	    e1000_i210.o igb_ptp.o igb_hwmon.o
diff --git a/drivers/net/ethernet/intel/igb/bcm_phy.c b/drivers/net/ethernet/intel/igb/bcm_phy.c
new file mode 100644
index 0000000..edb337a
--- /dev/null
+++ b/drivers/net/ethernet/intel/igb/bcm_phy.c
@@ -0,0 +1,208 @@
+#include <linux/brcmphy.h>
+
+#include "e1000_hw.h"
+
+/*
+ * 1000Base-T Control Register
+ */
+#define MII_BCM54XX_AUX_CTL_ENCODE(val) (((val & 0x7) << 12) | (val & 0x7))
+
+/*
+ * MII Link Advertisment
+ */
+#define MII_ANA_ASF             (1 << 0) /* Advertise Selector Field */
+#define MII_ANA_HD_10           (1 << 5) /* Half duplex 10Mb/s supported */
+#define MII_ANA_FD_10           (1 << 6) /* Full duplex 10Mb/s supported */
+#define MII_ANA_HD_100          (1 << 7) /* Half duplex 100Mb/s supported */
+#define MII_ANA_FD_100          (1 << 8) /* Full duplex 100Mb/s supported */
+#define MII_ANA_T4              (1 << 9) /* T4 */
+#define MII_ANA_PAUSE           (1 << 10)/* Pause supported */
+#define MII_ANA_ASYM_PAUSE      (1 << 11)/* Asymmetric pause supported */
+#define MII_ANA_RF              (1 << 13)/* Remote fault */
+#define MII_ANA_NP              (1 << 15)/* Next Page */
+
+#define MII_ANA_ASF_802_3       (1)      /* 802.3 PHY */
+
+/*
+ * BCM54XX: Shadow registers
+ * Shadow values go into bits [14:10] of register 0x1c to select a shadow
+ * register to access.
+ */
+#define BCM54XX_SHD_AUTODETECT  0x1e    /* 11110: Auto detect Regisrer */
+#define BCM54XX_SHD_MODE        0x1f    /* 11111: Mode Control Register */
+#define BCM54XX_SHD_MODE_SER    1 << 6
+
+/*
+ * Indirect register access functions for the 1000BASE-T/100BASE-TX/10BASE-T
+ * 0x1c shadow registers.
+ */
+
+static int bcmphy_write(struct e1000_hw *hw, u32 reg, u16 val)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+
+	return phy->ops.write_reg(hw, reg, val);
+}
+
+static u16 bcmphy_read(struct e1000_hw *hw, u32 reg)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	u16 val = 0;
+
+	phy->ops.read_reg(hw, reg, &val);
+	return val;
+}
+
+static int bcm54xx_shadow_read(struct e1000_hw *hw, u16 shadow)
+{
+	bcmphy_write(hw, MII_BCM54XX_SHD, MII_BCM54XX_SHD_VAL(shadow));
+	return MII_BCM54XX_SHD_DATA(bcmphy_read(hw, MII_BCM54XX_SHD));
+}
+
+static int bcm54xx_shadow_write(struct e1000_hw *hw, u16 shadow, u16 val)
+{
+	return bcmphy_write(hw, MII_BCM54XX_SHD,
+				MII_BCM54XX_SHD_WRITE |
+				MII_BCM54XX_SHD_VAL(shadow) |
+				MII_BCM54XX_SHD_DATA(val));
+}
+
+static int bcm54xx_auxctl_write(struct e1000_hw *hw, u16 regnum, u16 val)
+{
+	return bcmphy_write(hw, MII_BCM54XX_AUX_CTL, regnum | val);
+}
+
+static int bcm54xx_config_init(struct e1000_hw *hw)
+{
+	int reg, err;
+
+	reg = bcmphy_read(hw, MII_BCM54XX_ECR);
+	if (reg < 0)
+		return reg;
+
+	/* Mask interrupts globally.  */
+	reg |= MII_BCM54XX_ECR_IM;
+	err = bcmphy_write(hw, MII_BCM54XX_ECR, reg);
+	if (err < 0)
+		return err;
+
+	/* Unmask events we are interested in.  */
+	reg = ~(MII_BCM54XX_INT_DUPLEX |
+		MII_BCM54XX_INT_SPEED |
+		MII_BCM54XX_INT_LINK);
+	err = bcmphy_write(hw, MII_BCM54XX_IMR, reg);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+void bcm54616s_linkup(struct e1000_hw *hw, int speed, int duplex)
+{
+	u16 regval;
+
+	/* set speed and full duplex*/
+	regval = bcmphy_read(hw, PHY_CONTROL);
+
+	regval &= ~(MII_CR_SPEED_SELECT_MSB |
+		    MII_CR_SPEED_SELECT_LSB |
+		    MII_CR_FULL_DUPLEX);
+
+	switch (speed) {
+	case SPEED_10:
+		regval |= MII_CR_SPEED_10;
+		break;
+	case SPEED_100:
+		regval |= MII_CR_SPEED_100;
+		break;
+	case SPEED_1000:
+	default:
+		regval |= MII_CR_SPEED_1000;
+		break;
+	}
+
+	switch (duplex) {
+	case FULL_DUPLEX:
+		regval |= MII_CR_FULL_DUPLEX;
+		break;
+	}
+
+	bcmphy_write(hw, PHY_CONTROL, regval);
+
+	regval = bcmphy_read(hw, PHY_CONTROL);
+	regval &= ~(MII_CR_ISOLATE);
+	bcmphy_write(hw, PHY_CONTROL, regval);
+}
+
+int bcm54616s_config_init(struct e1000_hw *hw)
+{
+	int err, i;
+	u16 regval;
+
+	/* reset PHY */
+	regval = 1 << 15;
+	bcmphy_write(hw, PHY_CONTROL, regval);
+
+	mdelay(10);
+
+	/* disable Power down and iso */
+	regval = bcmphy_read(hw, PHY_CONTROL);
+	regval &= ~(MII_CR_POWER_DOWN | MII_CR_ISOLATE);
+	bcmphy_write(hw, PHY_CONTROL, regval);
+
+	/* disable suport I */
+	/*0000 0100 1100 0010 */
+	bcm54xx_auxctl_write(hw, 0, 0x04c2);
+
+	/* set 1000base-T */
+	regval = bcmphy_read(hw, PHY_1000T_CTRL);
+	regval |= (CR_1000T_FD_CAPS | CR_1000T_REPEATER_DTE);
+	bcmphy_write(hw, PHY_1000T_CTRL, regval);
+
+	/* set ctrl  */
+	regval = (MII_CR_SPEED_1000 |
+		  MII_CR_FULL_DUPLEX |
+		  MII_CR_SPEED_SELECT_MSB);
+	bcmphy_write(hw, PHY_CONTROL, regval);
+
+	/* Setup read from auxilary control shadow register 7 */
+	regval = MII_BCM54XX_AUX_CTL_ENCODE(7);
+	bcmphy_write(hw, MII_BCM54XX_AUX_CTL, regval);
+
+	/* Read Misc Control register */
+	regval = bcmphy_read(hw, MII_BCM54XX_AUX_CTL);
+	regval &= 0x8fff;
+	regval |= 0x8010;
+	bcmphy_write(hw, MII_BCM54XX_AUX_CTL, regval);
+
+	/* Enable auto-detect and copper prefer */
+	bcm54xx_shadow_write(hw, BCM54XX_SHD_AUTODETECT, 0x31);
+
+	err = bcm54xx_config_init(hw);
+
+	/* set link parner */
+	regval = MII_ANA_ASF_802_3 |
+		 MII_ANA_HD_10 |
+		 MII_ANA_HD_100 |
+		 MII_ANA_FD_10 |
+		 MII_ANA_FD_100 |
+		 MII_ANA_PAUSE |
+		 MII_ANA_ASYM_PAUSE;
+	bcmphy_write(hw, PHY_AUTONEG_ADV, regval);
+
+	i = 0;
+	while (1) {
+		regval = bcm54xx_shadow_read(hw, BCM54XX_SHD_MODE);
+		if (regval & BCM54XX_SHD_MODE_SER)
+			break;
+
+		if (i++ > 500) {
+			/* hw_dbg("SERDES no link %x\n", regval); */
+			break;
+		}
+
+		mdelay(1);   /* 1 ms */
+	}
+
+	return err;
+}
diff --git a/drivers/net/ethernet/intel/igb/e1000_82575.c b/drivers/net/ethernet/intel/igb/e1000_82575.c
index d9aaa13..6d58401 100644
--- a/drivers/net/ethernet/intel/igb/e1000_82575.c
+++ b/drivers/net/ethernet/intel/igb/e1000_82575.c
@@ -342,6 +342,10 @@ static s32 igb_init_phy_params_82575(struct e1000_hw *hw)
 		break;
 	case BCM54616_E_PHY_ID:
 		phy->type = e1000_phy_bcm54616;
+		phy->ops.check_polarity = NULL;
+		phy->ops.get_phy_info = igb_get_phy_info_bcm;
+		phy->ops.force_speed_duplex = igb_phy_force_speed_duplex_bcm;
+		bcm54616s_config_init(hw);
 		break;
 	default:
 		ret_val = -E1000_ERR_PHY;
@@ -1663,6 +1667,7 @@ static s32 igb_setup_copper_link_82575(struct e1000_hw *hw)
 		ret_val = igb_copper_link_setup_82580(hw);
 		break;
 	case e1000_phy_bcm54616:
+		ret_val = igb_copper_link_setup_bcm(hw);
 		break;
 	default:
 		ret_val = -E1000_ERR_PHY;
diff --git a/drivers/net/ethernet/intel/igb/e1000_82575.h b/drivers/net/ethernet/intel/igb/e1000_82575.h
index acf0605..4ddc2a7 100644
--- a/drivers/net/ethernet/intel/igb/e1000_82575.h
+++ b/drivers/net/ethernet/intel/igb/e1000_82575.h
@@ -32,6 +32,8 @@ s32 igb_read_i2c_byte(struct e1000_hw *hw, u8 byte_offset, u8 dev_addr,
 		      u8 *data);
 s32 igb_write_i2c_byte(struct e1000_hw *hw, u8 byte_offset, u8 dev_addr,
 		       u8 data);
+void bcm54616s_linkup(struct e1000_hw *hw, int speed, int duplex);
+int bcm54616s_config_init(struct e1000_hw *hw);
 
 #define ID_LED_DEFAULT_82575_SERDES ((ID_LED_DEF1_DEF2 << 12) | \
 				     (ID_LED_DEF1_DEF2 <<  8) | \
diff --git a/drivers/net/ethernet/intel/igb/e1000_defines.h b/drivers/net/ethernet/intel/igb/e1000_defines.h
index ce95b7e..7ac57df 100644
--- a/drivers/net/ethernet/intel/igb/e1000_defines.h
+++ b/drivers/net/ethernet/intel/igb/e1000_defines.h
@@ -630,10 +630,14 @@
 #define E1000_PCS_LSTS_AN_COMPLETE	0x10000
 
 /* PHY Control Register */
+#define MII_CR_SPEED_SELECT_MSB 0x0040  /* bits 6,13: 10=1000, 01=100, 00=10 */
+#define MII_CR_COLL_TEST_ENABLE 0x0080  /* Collision test enable */
 #define MII_CR_FULL_DUPLEX      0x0100  /* FDX =1, half duplex =0 */
 #define MII_CR_RESTART_AUTO_NEG 0x0200  /* Restart auto negotiation */
+#define MII_CR_ISOLATE          0x0400  /* Isolate PHY from MII */
 #define MII_CR_POWER_DOWN       0x0800  /* Power down */
 #define MII_CR_AUTO_NEG_EN      0x1000  /* Auto Neg Enable */
+#define MII_CR_SPEED_SELECT_LSB 0x2000  /* bits 6,13: 10=1000, 01=100, 00=10 */
 #define MII_CR_LOOPBACK         0x4000  /* 0 = normal, 1 = loopback */
 #define MII_CR_RESET            0x8000  /* 0 = normal, 1 = PHY reset */
 #define MII_CR_SPEED_1000       0x0040
@@ -659,8 +663,11 @@
 /* Autoneg Expansion Register */
 
 /* 1000BASE-T Control Register */
+#define CR_1000T_ASYM_PAUSE      0x0080 /* Advertise asymmetric pause bit */
 #define CR_1000T_HD_CAPS         0x0100 /* Advertise 1000T HD capability */
 #define CR_1000T_FD_CAPS         0x0200 /* Advertise 1000T FD capability  */
+#define CR_1000T_REPEATER_DTE    0x0400 /* 1=Repeater/switch device port */
+					/* 0=DTE device */
 #define CR_1000T_MS_VALUE        0x0800 /* 1=Configure PHY as Master */
 					/* 0=Configure PHY as Slave */
 #define CR_1000T_MS_ENABLE       0x1000 /* 1=Master/Slave manual config value */
diff --git a/drivers/net/ethernet/intel/igb/e1000_phy.c b/drivers/net/ethernet/intel/igb/e1000_phy.c
index 2788a54..c2c0e2b 100644
--- a/drivers/net/ethernet/intel/igb/e1000_phy.c
+++ b/drivers/net/ethernet/intel/igb/e1000_phy.c
@@ -467,6 +467,28 @@ s32 igb_write_phy_reg_igp(struct e1000_hw *hw, u32 offset, u16 data)
 }
 
 /**
+ *  igb_copper_link_setup_bcm - Setup bcm PHY for copper link
+ *  @hw: pointer to the HW structure
+ *
+ *  Sets up copper link.
+ **/
+s32 igb_copper_link_setup_bcm(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret_val;
+	u16 phy_data;
+
+	if (phy->reset_disable)
+		return 0;
+
+	ret_val = phy->ops.read_reg(hw, PHY_CONTROL, &phy_data);
+	phy_data &= ~(MII_CR_ISOLATE);
+	ret_val = phy->ops.write_reg(hw, PHY_CONTROL, phy_data);
+
+	return 0;
+}
+
+/**
  *  igb_copper_link_setup_82580 - Setup 82580 PHY for copper link
  *  @hw: pointer to the HW structure
  *
@@ -1676,6 +1698,72 @@ s32 igb_phy_has_link(struct e1000_hw *hw, u32 iterations,
 }
 
 /**
+ *  igb_phy_force_speed_duplex_bcm - Force speed/duplex for bcm PHY
+ *  @hw: pointer to the HW structure
+ *
+ *  Calls the PHY setup function to force speed and duplex. Waits
+ *  for link and returns successful if link up is successful, else
+ *  -E1000_ERR_PHY (-2).
+ **/
+s32 igb_phy_force_speed_duplex_bcm(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret_val;
+	u16 phy_data;
+	bool link;
+
+	ret_val = phy->ops.read_reg(hw, PHY_CONTROL, &phy_data);
+	if (ret_val)
+		goto out;
+
+	igb_phy_force_speed_duplex_setup(hw, &phy_data);
+
+	phy_data &= ~(MII_CR_POWER_DOWN | MII_CR_ISOLATE);
+
+	ret_val = phy->ops.write_reg(hw, PHY_CONTROL, phy_data);
+	if (ret_val)
+		goto out;
+
+#if 0
+	/* Clear Auto-Crossover to force MDI manually.  IGP requires MDI
+	 * forced whenever speed and duplex are forced.
+	 */
+	ret_val = phy->ops.read_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data);
+	if (ret_val)
+		goto out;
+
+	phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
+	phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
+
+	ret_val = phy->ops.write_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data);
+	if (ret_val)
+		goto out;
+
+	hw_dbg("IGP PSCR: %X\n", phy_data);
+#endif
+	udelay(1);
+
+	if (phy->autoneg_wait_to_complete) {
+		hw_dbg("Waiting for forced speed/duplex link on BCM phy.\n");
+
+		ret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT, 100000, &link);
+		if (ret_val)
+			goto out;
+
+		if (!link)
+			hw_dbg("Link taking longer than expected.\n");
+
+		/* Try once more */
+		ret_val = igb_phy_has_link(hw, PHY_FORCE_LIMIT, 100000, &link);
+		if (ret_val)
+			goto out;
+	}
+
+out:
+	return ret_val;
+}
+
+/**
  *  igb_get_cable_length_m88 - Determine cable length for m88 PHY
  *  @hw: pointer to the HW structure
  *
@@ -2058,6 +2146,39 @@ s32 igb_get_phy_info_igp(struct e1000_hw *hw)
 }
 
 /**
+ *  igb_get_phy_info_bcm - Retrieve PHY information
+ *  @hw: pointer to the HW structure
+ *
+ *  Valid for only copper links.  Read the PHY status register (sticky read)
+ *  to verify that link is up.
+ **/
+s32 igb_get_phy_info_bcm(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &hw->phy;
+	s32 ret_val;
+	bool link;
+
+	if (phy->media_type != e1000_media_type_copper) {
+		hw_dbg("Phy info is only valid for copper media\n");
+		ret_val = -E1000_ERR_CONFIG;
+		goto out;
+	}
+
+	ret_val = igb_phy_has_link(hw, 1, 0, &link);
+	if (ret_val)
+		goto out;
+
+	if (!link) {
+		hw_dbg("Phy info is only valid if link is up\n");
+		ret_val = -E1000_ERR_CONFIG;
+		goto out;
+	}
+
+out:
+	return ret_val;
+}
+
+/**
  *  igb_phy_sw_reset - PHY software reset
  *  @hw: pointer to the HW structure
  *
diff --git a/drivers/net/ethernet/intel/igb/e1000_phy.h b/drivers/net/ethernet/intel/igb/e1000_phy.h
index 9b622b3..edbe3df 100644
--- a/drivers/net/ethernet/intel/igb/e1000_phy.h
+++ b/drivers/net/ethernet/intel/igb/e1000_phy.h
@@ -75,6 +75,9 @@ s32  igb_get_cable_length_82580(struct e1000_hw *hw);
 s32  igb_read_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 *data);
 s32  igb_write_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 data);
 s32  igb_check_polarity_m88(struct e1000_hw *hw);
+s32  igb_copper_link_setup_bcm(struct e1000_hw *hw);
+s32  igb_phy_force_speed_duplex_bcm(struct e1000_hw *hw);
+s32  igb_get_phy_info_bcm(struct e1000_hw *hw);
 
 /* IGP01E1000 Specific Registers */
 #define IGP01E1000_PHY_PORT_CONFIG        0x10 /* Port Config */
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index c6c2562..f9d2e88 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -4492,6 +4492,14 @@ static void igb_watchdog_task(struct work_struct *work)
 							 &adapter->link_speed,
 							 &adapter->link_duplex);
 
+			switch (hw->phy.type) {
+			case e1000_phy_bcm54616:
+				bcm54616s_linkup(hw, adapter->link_speed, adapter->link_duplex);
+				break;
+			default:
+				break;
+			}
+
 			ctrl = rd32(E1000_CTRL);
 			/* Links status message must follow this format */
 			netdev_info(netdev,
-- 
2.7.4

